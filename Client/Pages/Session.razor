@page "/game/{SessionId}"
@using Microsoft.AspNetCore.SignalR.Client
@using System.IO.Compression
@using System.Text
@using WordleOff.Shared.Games
@inject NavigationManager NavigationManager
@inject IJSRuntime jsRuntime
@implements IAsyncDisposable

<div style=@($"display: {(sessionFound ? "none" : "")};") class="div-center div-center-vertical">
  @searchSessionMessage
  <hr />
  <div>
      Go to <span class="wordleoff-dot-com" @onclick="NavigateToNewGameScreen">https://www.wordleoff.com/</span>
      <br />to start a new session
  </div>
</div>
<div style=@($"display: {(!sessionInitialized && sessionFound? "" : "none")};") class="div-center">
  <div class="div-center div-center-vertical">
    <div>
      <div class="div-margin-1">Your Name:</div>
      <input class="div-margin-1" @bind="playerName" disabled="@(!IsConnected || IsGameInProgress)" maxlength="16" />
      <button class="div-margin-1" @onclick="JoinSession" disabled="@(!IsConnected || IsGameInProgress)">Join</button>
    </div>
    <div>
      @joinErrorMessage
    </div>
    <hr />
    <div>
      Go to <span class="wordleoff-dot-com" @onclick="NavigateToNewGameScreen">https://www.wordleoff.com/</span>
      <br />to start a new session
    </div>
  </div>
</div>
<div class="screen">
  <div style=@($"display: {(sessionInitialized && sessionFound ? "" : "none")};")
     class="page"
     @onkeydown="@KeyDown"
     tabindex="0"
     @ref="gameDiv">
    <div>
      @RenderTitleLogo()
      @RenderSessionId()
    </div>
    <div class="div-center player-data" style=@boardZoomString)>
      @RenderPlayerDataTable()
    </div>
    <div>
      <div class="div-center div-center-vertical">
        <div class="div-height-1">
          @submitError
          @holdMessage
        </div>    
        <div
          style=@((alreadyGuessedCorrectly || guessLimitReached) && allPlayersAtMaxGuesses ? "" : "visibility: hidden;")
          @onclick="NavigateToDictionaryDotCom"
          class="dictionary-dot-com"
        >
          (See definition on dictionary.com in a new window.)
        </div>
      </div>
      @RenderKeyboard()
      @RenderResetButton()
    </div>
  </div>
</div>


@code {
  [Parameter]
  public String SessionId { get; set; } = "";

  private String playerName = "";
  private String joinErrorMessage = "";
  private String guess = "";
  private String submitError = "";
  private String holdMessage = "";
  private String searchSessionMessage = "Searching....";
  private HubConnection? hubConnection;
  private Boolean canSubmitNewGuess;
  private Boolean behindOthers = false;
  private Boolean alreadyGuessedCorrectly = false;
  private Boolean guessLimitReached = false;
  Int32 maxGuessesAmongPlayers = 0;
  Boolean allPlayersAtMaxGuesses = false;
  private Boolean gameOver = false;
  private Boolean sessionInitialized = false;
  private Boolean sessionFound = false;
  private HashSet<String> fullWords = new();
  private String? correctAnswer;
  private String resetButtonClass = "";
  private String copyIdMessage = "";
  private String boardZoomString = "";
  private String keyboardScaleString = "";
  private System.Timers.Timer? timer;
  private Dictionary<String, PlayerData> playerDataDictionary = new();

  private ElementReference gameDiv;

  protected override async Task OnInitializedAsync()
  {
    BrowserResizeService.OnResize += BrowserResizeHandler;
    await jsRuntime.InvokeVoidAsync("browserResize.registerResizeCallback");

    hubConnection = new HubConnectionBuilder()
      .WithUrl(NavigationManager.ToAbsoluteUri("/WordleOffHub"))
      .Build();
    hubConnection.Closed += async (e) => await OnClosed(e);

    hubConnection.On<Byte[]>("ServerFullWordsCompressed", async (compressedFullWordsBytes) => await StoreFullWords(compressedFullWordsBytes));
    hubConnection.On<Dictionary<String, PlayerData>>("ServerPlayerData", async (newPlayerDataDictionary) => await UpdatePlayerData(newPlayerDataDictionary));
    hubConnection.On<String>("ServerCurrentAnswer", (correctAnswer) => UpdateCurrentAnswer(correctAnswer));
    hubConnection.On<ServerJoinError>("ServerJoinError", (error) => DisplayJoinErrorMessage(error));
    hubConnection.On<Boolean>("ServerSessionFindResult", (result) => HandleSessionFindResult(result));

    await hubConnection.StartAsync();

    await hubConnection.InvokeAsync("ClientSearchSession", SessionId);
  }

  #region Received from Server

  public async Task StoreFullWords(Byte[] compressedFullWordsBytes)
  {
    await Task.Run(() =>
    {
      MemoryStream input = new(compressedFullWordsBytes);
      MemoryStream output = new();
      using (DeflateStream dstream = new DeflateStream(input, CompressionMode.Decompress))
      {
        dstream.CopyTo(output);
      }
      Byte[] decompressedBytes = output.ToArray();
      String fullWordsString = UTF8Encoding.UTF8.GetString(decompressedBytes);
      fullWords = fullWordsString.Split("\n").ToHashSet();
    });
  }

  public async Task UpdatePlayerData(Dictionary<String, PlayerData> newPlayerDataDictionary)
  {
    sessionInitialized = true;
    if (playerDataDictionary.ContainsKey(playerName) && newPlayerDataDictionary.ContainsKey(playerName))
      if (playerDataDictionary[playerName].PlayData.Count < newPlayerDataDictionary[playerName].PlayData.Count)
        guess = "";

    playerDataDictionary = newPlayerDataDictionary;
    if (hubConnection is not null)
    {
      playerName = playerDataDictionary.First(x => x.Value.ConnectionId == hubConnection.ConnectionId).Key;
      UpdateGameStates();
    }
    UpdateResetButtonClass();
    await BrowserResizeHandler();
    await jsRuntime.InvokeVoidAsync("setFocusToElement", gameDiv);
  }

  public void HandleSessionFindResult(Boolean result)
  {
    if (result)
      sessionFound = true;
    else
      searchSessionMessage = "Session not found!!";
    StateHasChanged();
  }

  public void DisplayJoinErrorMessage(ServerJoinError error)
  {
    joinErrorMessage = ServerJoinErrorMessages.Maps[error];
    StateHasChanged();
  }

  #endregion


  #region Send to Server

  public async Task JoinSession()
  {
    if (playerName.Length == 0)
    {
      joinErrorMessage = "You name cannot be empty!";
      return;
    }
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientConnectNew", SessionId, playerName);
  }

  public async Task UpdatePlayerName()
  {
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientUpdatePlayerName", playerName);
  }

  public async Task SubmitGuess()
  {
    if (hubConnection is not null && correctAnswer is not null)
    {
      if (guess.Length != correctAnswer!.Length)
      {
        submitError = $"Guess a {correctAnswer.Length}-letter word";
        return;
      }
      else if (!fullWords.Contains(guess.ToLower()))
      {
        submitError = "Not a word!";
        return;
      }
      if (canSubmitNewGuess)
        await hubConnection.SendAsync("ClientSubmitGuess", playerName, guess.ToLower());
      submitError = "";
    }
  }

  public async Task Reconnect()
  {
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientReconnect", SessionId, playerName);
  }

  public void UpdateCurrentAnswer(String newCorrectAnswer) => correctAnswer = newCorrectAnswer;

  #endregion


  #region Other Client Code

  public async Task KeyDown(KeyboardEventArgs e) => await HandleKey(e.Key);

  public async Task HandleKey(String key)
  {
    PlayerData playerData = playerDataDictionary[playerName];
    if (correctAnswer is not null && playerData.PlayData.Count < 6 && !playerData.AnswerGuessCorrectly(correctAnswer) && canSubmitNewGuess)
    {
      if (key == "Backspace" && guess.Length > 0)
      {
        guess = guess.Remove(guess.Length - 1);
        submitError = "";
      }
      else if (key == "Enter")
      {
        if (guess.Length == correctAnswer.Length)
          await SubmitGuess();
      }
      else if (key.Length == 1)
      {
        Char c = key.ToLower()[0];
        if ('a' <= c && c <= 'z' && guess.Length < correctAnswer.Length)
          guess += c;
      }
    }
  }

  public async Task BrowserResizeHandler()
  {
    //Single logoX = 350;
    Single logoY = 86;
    Single boardX = 365;
    Single boardY = 456;
    Single keyboardX = 420;
    Single keyboardY = 240;

    Single newWidth = await jsRuntime.InvokeAsync<Single>("browserResize.getInnerWidth");
    Single newHeight = await jsRuntime.InvokeAsync<Single>("browserResize.getInnerHeight");

    Single currentBoardX = boardX * playerDataDictionary.Count;
    Single currentBoardY = boardY; // This may change when I implement flex box layout

    Single allowedHeight = newHeight - (logoY + keyboardY); // WindowHeight - (Logo + Keyboard)
    if (allowedHeight < keyboardY)
      allowedHeight = keyboardY; // Minimum height
    Single allowedWidth = newWidth;

    if (allowedWidth >= Math.Max(currentBoardX, keyboardX) && allowedHeight >= boardY)
    {
      boardZoomString = "";
      keyboardScaleString  = "";
    }
    else
    {
      // Adjust Size for Board
      if (allowedWidth < currentBoardX || allowedHeight < boardY)
      {
        Single allowedRatio = allowedWidth / allowedHeight;
        Single boardRatio = currentBoardX / boardY;

        Single scaleFactor = 1.0f;
        if (allowedRatio > boardRatio) // Scale based on height
          scaleFactor = allowedHeight / boardY;
        else // Scale based on width
          scaleFactor = allowedWidth / currentBoardX;
        boardZoomString = $"zoom: {scaleFactor}; -moz-transform: scale({scaleFactor});";
      }

      if (allowedWidth < keyboardX)
      {
        Single scaleFactor = allowedWidth / keyboardX;
        keyboardScaleString = $"transform: scale({scaleFactor}, 1.0);";
      }
    }
    StateHasChanged();
  }

  public async Task CopyUrlToClipboard()
  {
    await jsRuntime.InvokeVoidAsync("navigator.clipboard.writeText", $"https://www.wordleoff.com/game/{SessionId}");
    copyIdMessage = " (Copied!!!)";
    timer = new(5000);
    timer.AutoReset = false;
    timer.Elapsed += async (sender, e) =>
    {
      await Task.Run(() =>
      {
        copyIdMessage = "";
        StateHasChanged();
      });
    };
    timer.Start();
  }

  public async Task NavigateToDictionaryDotCom()
  {
    await jsRuntime.InvokeAsync<Object>("open", $"https://www.dictionary.com/browse/{correctAnswer}", "_blank");
  }

  public void NavigateToNewGameScreen() => NavigationManager.NavigateTo("/");

  public Boolean IsConnected => hubConnection?.State == HubConnectionState.Connected;

  public Boolean IsGameInProgress => playerDataDictionary.Any(x => x.Value.PlayData.Count > 0);

  public void UpdateResetButtonClass()
  {
    if (correctAnswer is not null)
    {
      if (playerDataDictionary.Values.All(x => x.PlayData.Count == 6 || x.AnswerGuessCorrectly(correctAnswer)))
        resetButtonClass = "guess-correct";
      else if (playerDataDictionary.Values.All(x => x.PlayData.Count == 0))
        resetButtonClass = "guess-absent";
      else
        resetButtonClass = "guess-present";
    }
    else
      resetButtonClass = "";
  }

  public void UpdateGameStates()
  {
    behindOthers = false;
    alreadyGuessedCorrectly = false;
    guessLimitReached = false;
    Boolean keyExist = false;

    keyExist = playerDataDictionary.ContainsKey(playerName);
    if (keyExist && correctAnswer is not null)
    {
      if (playerDataDictionary[playerName].AnswerGuessCorrectly(correctAnswer))
        alreadyGuessedCorrectly = true;
      Int32 myGuessCount = playerDataDictionary[playerName].PlayData.Count;
      behindOthers = playerDataDictionary.Values.All((x) =>
      {
        return x.AnswerGuessCorrectly(correctAnswer)
                || x.PlayData.Count >= myGuessCount;
      });
      guessLimitReached = playerDataDictionary[playerName].PlayData.Count == 6;

      maxGuessesAmongPlayers = playerDataDictionary.Values.Max(x => x.PlayData.Count);
      allPlayersAtMaxGuesses = playerDataDictionary.Values.All(x => x.PlayData.Count == maxGuessesAmongPlayers || x.AnswerGuessCorrectly(correctAnswer));
      gameOver = playerDataDictionary.Values.All(x => x.PlayData.Count == 6 || x.AnswerGuessCorrectly(correctAnswer));
    }    

    if (!behindOthers && keyExist)
      holdMessage = "Wait until all players submit their guesses.";
    else if (alreadyGuessedCorrectly)
      holdMessage = $"{correctAnswer?.ToUpper()} is correct!{(playerDataDictionary.Count > 1 && !gameOver ? " Entering God Mode!" : "")}";
    else if (!alreadyGuessedCorrectly && guessLimitReached)
      holdMessage = $"The answer is {correctAnswer?.ToUpper() ?? ""}";
    else
      holdMessage = "";
    canSubmitNewGuess = behindOthers && !alreadyGuessedCorrectly && !guessLimitReached;
  }

  private async Task NewGame()
  {
    if (!await jsRuntime.InvokeAsync<Boolean>(
      "confirm",
      "You'll lose everyone's progress and start a new game. Do you really want to reset?"
    ))
      return;
    if (hubConnection is not null)
      await hubConnection.SendAsync("ClientResetCurrentSession", SessionId);
  }

  private async Task OnClosed(Exception? e)
  {
    if (hubConnection is not null)
    {
      await hubConnection.StartAsync();
      await Reconnect();
    }
  }

  public async ValueTask DisposeAsync()
  {
    if (hubConnection is not null)
      await hubConnection.DisposeAsync();
  }

  #endregion


  #region RenderFragments

  private RenderFragment RenderTitleLogo()
  {
    return __builder =>
    {
      <div class="div-center">
        <div class="title-logo-row">WORDLEOFF</div>
      </div>
    };
  }

  private RenderFragment RenderSessionId()
  {
    return __builder =>
    {
      <div class="div-center div-center-vertical">
        <div class="session-id-row" @onclick="CopyUrlToClipboard">
          @foreach (Char c in SessionId)
          {
            <div class="guess-tile guess-tile-session-id guess-absent">@c</div>
          }
        </div>
        <div class="copy-id"><span>Click ID Above to Copy URL</span><span>@copyIdMessage</span></div>
      </div>
    };
  }

  private RenderFragment RenderPlayerDataTable()
  {
    return __builder =>
    {
      if (correctAnswer is null)
      {
        <div></div>
      }
      else
      {
        if (playerDataDictionary.Count == 0)
          return;
        Boolean godMode = playerDataDictionary.ContainsKey(playerName) ? (playerDataDictionary[playerName].AnswerGuessCorrectly(correctAnswer) && allPlayersAtMaxGuesses) || gameOver : false;

        Int32 maxIndex = playerDataDictionary.Count == 0 ? -1 : playerDataDictionary.Max(x => x.Value.Index);
        List<KeyValuePair<String, PlayerData>?> orderedList = new();
        for (Int32 i = 1; i <= maxIndex; ++i)
        {
          var matchingPlayers = playerDataDictionary.Where(x => x.Value.Index == i);
          if (matchingPlayers.Count() > 0)
            orderedList.Add(matchingPlayers.First());
        }
        <table>
          <tr>
            @for (Int32 i = 0; i < orderedList.Count; ++i)
            {
              var pairValue = orderedList[i]!.Value;
              var currentPlayerName = pairValue.Key;
              var currentPlayerData = pairValue.Value;
              Boolean isCurrentPlayerLocal = playerName == currentPlayerName;
              Int32 emptyRowOffset = 0;
              if (isCurrentPlayerLocal)
                emptyRowOffset = 1;
              String youIndicator = (playerName == currentPlayerName) ? " (You)" : "";
              String borderClass = orderedList.Count > 1 && playerName == currentPlayerName ? "my-board" : "";
              <td>
                <div class=@($"play-container {borderClass}")>
                  <div>@($"{currentPlayerName}{youIndicator}")</div>
                  <div class="guess-board">
                    @for (Int32 j = 0; j < currentPlayerData.PlayData.Count; ++j)
                    {
                      String currentGuess = currentPlayerData.PlayData[j];
                      @if (j == maxGuessesAmongPlayers - 1 && !allPlayersAtMaxGuesses)
                        @RenderTempGuessRow(currentPlayerName, currentGuess)
                      else
                        @RenderGuessRow(currentGuess, !isCurrentPlayerLocal && !godMode)
                    }
                    @if (currentPlayerData.PlayData.Count < 6 && isCurrentPlayerLocal)
                    {
                      @RenderGuessingRow()
                    }
                    @for (Int32 j = currentPlayerData.PlayData.Count + emptyRowOffset; j < 6; ++j)
                    {
                      @RenderEmptyRow()
                    }
                  </div>
                </div>
              </td>
            }
          </tr>
        </table>
      }
    };
  }

  private RenderFragment RenderGuessRow(String currentGuess, Boolean hideLetters)
  {
    return __builder =>
    {
      if (correctAnswer is null)
      {
        <div></div>
      }
      else
      {
        List<Int32> colorList = new();
        Dictionary<Char, Int32> letterCountInAnswer = new();
        for (Int32 i = 0; i < correctAnswer.Length; ++i)
        {
          colorList.Add(0);
          if (letterCountInAnswer.ContainsKey(correctAnswer[i]))
            ++letterCountInAnswer[correctAnswer[i]];
          else
            letterCountInAnswer.Add(correctAnswer[i], 1);
        }
        for (Int32 i = 0; i < correctAnswer.Length; ++i)
          if (currentGuess[i] == correctAnswer[i])
          {
            colorList[i] = 2;
            --letterCountInAnswer[currentGuess[i]];
          }
        for (Int32 i = 0; i < correctAnswer.Length; ++i)
          if (correctAnswer.Contains(currentGuess[i]) && letterCountInAnswer[currentGuess[i]] > 0 && colorList[i] < 1)
          {
            colorList[i] = 1;
            --letterCountInAnswer[currentGuess[i]];
          }
        <div class="guess-row">
          @for (Int32 i = 0; i < correctAnswer.Length; ++i)
          {
            Char displayChar = hideLetters ? '?' : currentGuess[i];
            String backgroundColorCSS = "";
            @switch (colorList[i])
            {
              case 0:
                backgroundColorCSS = "guess-absent";
                break;
              case 1:
                backgroundColorCSS = "guess-present";
                break;
              case 2:
                backgroundColorCSS = "guess-correct";
                break;
            }
            <div class=@($"guess-tile {backgroundColorCSS}")>@displayChar</div>
          }
        </div>
      }
    };
  }

  private RenderFragment RenderTempGuessRow(String currentPlayerName, String currentGuess)
  {
    return __builder =>
    {
      <div class="guess-row">
        @if (playerName == currentPlayerName)
        {
          @foreach (Char c in currentGuess)
          {
            <div class="guess-tile guess-guessing">@c</div>
          }
        }
        else
        {
          @foreach (Char c in currentGuess)
          {
            <div class="guess-tile guess-guessing">?</div>
          }
        }
      </div>
    };
  }

  private RenderFragment RenderEmptyRow()
  {
    return __builder =>
    {
      if (correctAnswer is null)
      {
        <div></div>
      }
      else
      {
        <div class="guess-row">
          @foreach (Char c in correctAnswer)
          {
            <div class="guess-tile guess-empty"></div>
          }
        </div>
      }
    };
  }

  private RenderFragment RenderGuessingRow()
  {
    return __builder =>
    {
      if (correctAnswer is null)
      {
        <div></div>
      }
      else
      {
        <div class="guess-row">
          @for (Int32 i = 0; i < guess.Length; ++i)
          {
            <div class=@($"guess-tile guess-guessing")>@guess[i]</div>
          }
          @for (Int32 i = guess.Length; i < correctAnswer.Length; ++i)
          {
            <div class="guess-tile guess-empty"></div>
          }
        </div>
      }
    };
  }

  private RenderFragment RenderKeyboard()
  {
    return __builder =>
    {
      if (correctAnswer is not null)
      {
        List<String> playData = playerDataDictionary[playerName].PlayData;

        Dictionary<Char, Int32> letterTileValues = new();
        for (Char c = 'a'; c <= 'z'; ++c)
          letterTileValues.Add(c, -1);
        Int32 maxGuessesAmongPlayers = playerDataDictionary.Values.Max(x => x.PlayData.Count);
        Boolean allPlayersAtMaxGuesses = playerDataDictionary.Values.All(x => x.PlayData.Count == maxGuessesAmongPlayers || x.AnswerGuessCorrectly(correctAnswer));
        Boolean includeLast = (canSubmitNewGuess || (alreadyGuessedCorrectly && allPlayersAtMaxGuesses) || gameOver);

        Int32 playDataLimit = playData.Count - (includeLast ? 0 : 1);
        for (Int32 i = 0; i < playDataLimit; ++i)
        {
          String play = playData[i];
          for (Int32 j = 0; j < play.Length; ++j)
          {
            Char c = play[j];
            if (correctAnswer[j] == c)
              letterTileValues[c] = 2;
            else if (correctAnswer.Contains(c) && letterTileValues[c] < 2)
              letterTileValues[c] = 1;
            else if (letterTileValues[c] < 1)
              letterTileValues[c] = 0;
          }
        }
        Dictionary<Char, String> letterTileColors = new();
        foreach (var pair in letterTileValues)
        {
          letterTileColors.Add(
            pair.Key,
            pair.Value switch
            {
              -1 => "guess-guessing",
              0 => "guess-absent",
              1 => "guess-present",
              2 => "guess-correct",
              _ => "guess-guessing"
            }
          );
        }

        <div class="div-center">
          <div class="keyboard-board">
            <div class="div-center div-center-vertical" style=@keyboardScaleString>
              <div class="keyboard-row">
                @RenderKeyboardChar(letterTileColors, 'q')
                @RenderKeyboardChar(letterTileColors, 'w')
                @RenderKeyboardChar(letterTileColors, 'e')
                @RenderKeyboardChar(letterTileColors, 'r')
                @RenderKeyboardChar(letterTileColors, 't')
                @RenderKeyboardChar(letterTileColors, 'y')
                @RenderKeyboardChar(letterTileColors, 'u')
                @RenderKeyboardChar(letterTileColors, 'i')
                @RenderKeyboardChar(letterTileColors, 'o')
                @RenderKeyboardChar(letterTileColors, 'p')
              </div>
              <div class="keyboard-row">
                <div class=@($"guess-tile guess-tiles-offset-50")></div>
                @RenderKeyboardChar(letterTileColors, 'a')
                @RenderKeyboardChar(letterTileColors, 's')
                @RenderKeyboardChar(letterTileColors, 'd')
                @RenderKeyboardChar(letterTileColors, 'f')
                @RenderKeyboardChar(letterTileColors, 'g')
                @RenderKeyboardChar(letterTileColors, 'h')
                @RenderKeyboardChar(letterTileColors, 'j')
                @RenderKeyboardChar(letterTileColors, 'k')
                @RenderKeyboardChar(letterTileColors, 'l')
                <div class=@($"guess-tile guess-tiles-offset-50")></div>
              </div>
              <div class="keyboard-row">
                <div
                  class=@($"guess-tile guess-tile-keyboard-small guess-tiles-offset-150 guess-guessing")
                  @onclick="@(e => HandleKey("Enter"))">
                    Enter
                </div>
                @RenderKeyboardChar(letterTileColors, 'z')
                @RenderKeyboardChar(letterTileColors, 'x')
                @RenderKeyboardChar(letterTileColors, 'c')
                @RenderKeyboardChar(letterTileColors, 'v')
                @RenderKeyboardChar(letterTileColors, 'b')
                @RenderKeyboardChar(letterTileColors, 'n')
                @RenderKeyboardChar(letterTileColors, 'm')
                <div
                  class=@($"guess-tile guess-tile-keyboard guess-tiles-offset-150 guess-guessing")
                  @onclick="@(e => HandleKey("Backspace"))">
                    âŒ«
                </div>
              </div>
            </div>
          </div>
        </div>
      }
    };
  }

  private RenderFragment RenderKeyboardChar(Dictionary<Char, String> letterTileColors, Char renderChar)
  {
    return __builder =>
    {
      <div class=@($"guess-tile guess-tile-keyboard {letterTileColors[renderChar]}")
       @onclick="@(e => HandleKey(renderChar.ToString()))">
        @renderChar
      </div>
    };
  }

  private RenderFragment RenderResetButton()
  {
    return __builder =>
    {
      <div class="div-center">
        <div class="reset-row" @onclick="NewGame">
          <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>R</div>
          <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>E</div>
          <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>S</div>
          <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>E</div>
          <div class=@($"guess-tile guess-tile-small {@resetButtonClass}")>T</div>
        </div>
      </div>
    };
  }

  #endregion
}
